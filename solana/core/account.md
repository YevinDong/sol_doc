# Account

如果程序需要在Transaction之间存储状态，它使用Account来实现。帐户类似于操作系统(如Linux)中的文件，因为它们可能保存程序的任意数据。与文件一样，帐户也包括元数据，该元数据告诉运行库允许谁访问数据以及如何访问数据。

与文件不同，帐户包括文件生存期的元数据。这个生命周期由一些称为lamports的分数原生令牌表示。账户被保存在验证器内存中，并支付“租金”留在那里。每个验证器定期扫描所有帐户并收取租金。任何lamports降为零的帐户都将被清除。如果账户包含足够数量的lamport，也可以标记为免租金。

就像Linux用户使用路径查找文件一样，Solana客户端使用地址查找帐户。地址是256位公钥。

* 帐户用于存储数据
* 每个帐户都有一个唯一的地址
* 帐户的最大大小为10MB(10兆字节)
* PDA帐户的最大大小为10 KB(10 Kilo KB)
* PDA帐户可用于代表程序签名
* 帐户大小在创建时是固定的，但可以使用realloc进行调整
* 账户数据存储用租金支付
* 默认帐户所有者是系统程序


Account的定义如下：

```rust
pub struct Account {
        /// 账号余额
        pub lamports: u64,
        /// 表示存储的内容,如果是程序账号，这里data的内容就是合约编译后的代码.
        #[serde(with = "serde_bytes")]
        pub data: Vec<u8>,
        /// 表示这个Account可以被谁来操作
        pub owner: Pubkey,
        /// 是否是可执行账号(Program)
        pub executable: bool,
        /// 该帐户下一次还租金的时间
        pub rent_epoch: Epoch,
    }
```

## Account Model

Solana上有三种账户：

1. Data accounts 存储数据
2. Program accounts 存储可执行程序
3. Native accounts 原生程序

在数据账户中,有两种类型:

1. Data accounts 存储数据
    1. System owned accounts 系统拥有的帐户
    2. PDA (Program Derived Address) accounts 程序派生地址(PDA)账户

每个Account都有一个address(通常是公钥)和一个owner(程序帐户的地址)。帐户存储的完整字段列表如下所示。

| 字段       |              简介              |
| ---------- | :----------------------------: |
| lamports   |     此帐户拥有的lamport数      |
| owner      |       此帐户的程序所有者       |
| executable |           是否可执行           |
| data       |        原始数据字节数组        |
| rent_epoch | 下一个时期，这个账户将欠下租金 |

有几个重要的所有权规则：

* 只有数据帐户的所有者(owner)可以修改其data和lamports
* 任何人都可以向账户存入lamports
* 如果帐户的数据归零，则帐户的所有者可以被重新分配
  
程序帐户不存储状态。 例如，如果您有一个计数器程序，它允许您递增计数器，则必须创建两个帐户，一个帐户用于存储程序代码(Program Account)，另一个(Data Account)用于存储计数器。

为了防止帐户被删除，您必须支付[租金](/solana/intro/rent)。

## Signers

交易包括一个或多个数字签名，每个数字签名对应于由交易引用的账户地址。

每一个地址中都必须是 Ed25519 密钥对的公钥，并且签名表示匹配了私钥的签名，因此“授权”了交易。

在这种情况下，帐户被称为签名者。帐户是否是签名者作为帐户元数据的一部分传递给程序。然后程序可以使用这些信息来做出决策。

Solana的签名系统使用的是 Ed25519 ,说人话就是： Ed25519是一种计算快，安全性高，且生成的签名内容小的一种不对称加密算法。新一代公链几乎都支持这个算法。

Solana的用户理解的账号，就是一串Ed25519的私钥，各种钱包里面的助记词，会被转换成随机数种子， 再用随机数种子来生成一个私钥，所以助记词最终也是换算成私钥。所以用户账号的本质就是私钥，而用户账号的地址 则是这私钥对应的公钥,优于公钥是二进制的，为了可读性，将其进行Base58编码后的值

把这里的公钥和私钥放一起，就是所谓的Keypair，或者叫公私钥对。假设这里把私钥进行加密，并由用户来设置密码， 公钥作为这个私钥的索引。就实现了一个简单的钱包系统了。

## Read-only

Transactions可以[指定](./transactions)它引用的某些帐户被视为只读帐户，以便在Transaction之间启用并行帐户处理。

运行库允许多个程序同时读取只读帐户。如果程序试图修改只读帐户，则运行库将拒绝该事务。

## Executable

如果一个帐户在其元数据中被标记为“可执行”，那么它被认为是一个可以用指令和程序ID执行的程序。

当程序部署到执行引擎(SBF)时，加载器确定帐户数据中的字节码有效。如果是，加载程序将永久地将程序帐户标记为可执行。
